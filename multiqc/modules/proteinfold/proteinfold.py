import logging
import re
import warnings
import pickle

from multiqc.base_module import BaseMultiqcModule, ModuleNoSamplesFound
from multiqc.plots import bargraph

from Bio import PDB
from Bio import AlignIO

log = logging.getLogger(__name__)


class MultiqcModule(BaseMultiqcModule):
    """
    The module parses results generated by a variety of protein structure prediction programs in the [ProteinFold](https://nf-co.re/proteinfold/) pipeline.
    This includes [currently all WIP]:
        - [AlphaFold2](https://github.com/google-deepmind/alphafold)
        - [ColabFold](https://github.com/sokrypton/ColabFold) [currently not being worked on]
        - [ESMFold](https://github.com/facebookresearch/esm)
        - [RoseTTaFold-All-Atom](https://github.com/baker-laboratory/RoseTTAFold-All-Atom)
        - [HelixFold3](https://github.com/PaddlePaddle/PaddleHelix/tree/dev/apps/protein_folding/helixfold3) 

    This is intended to provide a summary of useful metrics for mass 'folding' a large set of proteins, either in terms of finishing for mulitmer interactions or comparing methods across whole proteomes. It provides a visual 'at-a-glance' report of relevant metrics (average pLDDT, ipTM, *etc*) and does not replace the per-protein interactive plot generated from nfcore/proteinfold

    ```
    Here's what some raw code looks like

    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="ProteinFold",
            anchor="proteinfold",
            href=["https://nf-co.re/proteinfold", "https://github.com/google-deepmind/alphafold", "https://github.com/sokrypton/ColabFold", "https://github.com/facebookresearch/esm", "https://github.com/baker-laboratory/RoseTTAFold-All-Atom", "https://github.com/PaddlePaddle/PaddleHelix/tree/dev/apps/protein_folding/helixfold3"],
            info="ProteinFold - protein structure inference methods through a single nextflow pipeline interface",
            doi=["10.1038/s41586-021-03819-2", "10.1038/s41592-022-01488-1",  "10.1126/science.ade2574", "10.1126/science.adl2528", "10.48550/arXiv.2408.16975"],
        )
   
        self.proteinfold_data = {}
        # I want to enable sample grouping: https://docs.seqera.io/multiqc/reports/customisation#sample-grouping


        for f in self.find_log_files('proteinfold/metrics'):
            self.add_data_source(f, section='metrics')        
            max_PAE, pTM, ipTM = self.parse_pickle_file(f)
            print(max_PAE, pTM, ipTM, mean_pLDDT, ranking_confidence)
            self.proteinfold_data[samplename] = {
                'max_PAE' : max_PAE, 
                'pTM' : pTM,
                'ipTM' : ipTM, 
                'mean_pLDDT' : mean_pLDDT, # mean pLDDT can be taken from .pkl, or pdb in absence of pickle. Here for 2nd check
                'ranking_confidence' : ranking_confidence 
            }
        
        for f in self.find_log_files('proteinfold/msas'):
            self.add_data_source(f, section='msas')
            filepath = f['root'] + '/' + f['fn']
            samplename = f['s_name']
            if f['fn'].endswith('.sto'):
                aln = AlignIO.read(filepath, "stockholm")
                msas = len(aln)
            if f['fn'].endswith('.a3m'):
                num_lines = sum(1 for _ in open(filepath, 'rb'))
                msas = int((num_lines/2)) # cheap hack but it holds and a3m parsing isn't support - A3MIO breaks of Bio.Alphabet
            self.proteinfold_data[samplename] = { 'msas' : msas }
        # Now I need to nest these msa samples underneath the protein sample names     
 
        # I can have this as "if pkl above doesn't exist go for the PDB"
        for f in self.find_log_files('proteinfold/structs'):
            self.add_data_source(f, section='structs')        
            avg_pLDDT = self.parse_pdb_file(f)
            self.proteinfold_data[samplename] = { ['avg_pLDDT'] : avg_pLDDT }
            
        
            #print(self.proteinfold_data) # DEBUG
            #print(f"'file: {filepath} - confidence {avg_pLDDT}") # DEBUG

        self.write_data_file(self.proteinfold_data, "proteinfold_data") # I want to structure and rename from avg_plDDT to summary_stats
        self.general_stats_table()
    

    def general_stats_table(self):
        '''
        Put protein structure prediction metrics into a general table for all different Deep Learning methods
        '''
        headers = {
#           "MSA depth": {
#               "title": "Related Sequence Depth (MSAs)",
#               "description": "The number of related sequences (across the whole protein) that could be retrieved from the MSA (Multiple Sequence Alignment) stage",
#           }, 
            "avg_pLDDT": {
                "title": "Confidence (average plDDT)",
                "description": "Structure prediction confidence score across all residues in the protein - from the mean pLDDT (predicted Local Distance Difference Test) value",
                "max": 100,
                "min": 0,
                "bars_zero_centrepoint": True,
                "cond_formatting_rules": {
                    "very-low": [ {"lt": 50}],
                    "low": [ {"gt": 50}, {"lt": 70}],
                    "high": [ {"gt": 70}, {"lt": 90}],
                    "very-high": [ {"gt": 90}]
                },
                "cond_formatting_colours": [
                    {"very-low": "#f0743e"},
                    {"low": "#f9d613"},
                    {"high": "#60c2e8"},
                    {"very-high": "#014ecc"}
                ]
            },
           "max_PAE": {
               "title": "Max error in relative positioning (PAE)",
               "description": "The maximum confidence in the relatively positioning between different domains - examine to validate pausible interactions - from the PAE (Predicted Align Error) score",
               "max": 30,
               "min": 0,
               "scale": "Greens",
           },
           "pTM": {
               "title": "Global accuracy (TM)",
               "description": "Global accuracy of the protein folded, less sensitive to localised inaccuracies than raw 3D atomic deviations (RMSD) - from the pTM (predicted Template Modelling) score",
               "max": 1,
               "min": 0,
               "scale": "Greys",
           },
           "ipTM": {
               "title": "Interface accuracy (ipTM)",
               "description": "Accuracy of the relative positions of two protein subunits from a mulitmer calcuation - from the ipTM (interface predicted Template Modelling) score",
               "max": 1,
               "min": 0,
               "scale": "Purples",
               },
        }
        self.general_stats_addcols(self.proteinfold_data, headers)


    def parse_pdb_file(self, filepath, samplename):
        '''
        Extract any MultiQC relevant info from the PDB files. Currently gets pLDDT via a function
        '''
        filepath = f['root'] + '/' + f['fn']
        samplename = f['s_name']
        avg_pLDDT = extract_pLDDT_pdb(filepath, samplename)
        return avg_pLDDT
    
    def parse_pickle_file(self, filepath, samplename):
        '''
        Extract metrics from .pkl files. Typically generated from AlphaFold2
        '''
        filepath = f['root'] + '/' + f['fn']
        samplename = f['s_name']
        with open(filepath, 'rb') as f:
            try:
                pkl_obj = pickle.load(f)
            except pickle.UnpicklingError: 
                return(None, None, None)
            max_PAE = pkl_obj['max_predicted_aligned_error']
            pTM = pkl_obj['ptm'] 
            ipTM = pkl_obj['iptm']      
            mean_pLDDT = float(round(pkl_obj['plddt'].mean(),2))      
            mean_pLDDT = float(round(pkl_obj['ranking_confidence'],2))      
        
        return(max_PAE, pTM, ipTM, mean_pLDDT, ranking_confidence)
    
def extract_pLDDT_pdb(filepath, samplename) -> float:
    '''
    Uses the BioPython PDB packaged to extract pLDDT values from the b-factor column. Iterates of PDB objects rather than processes raw file 
    '''
#    with warnings.catch_warnings():
    parser = PDB.PDBParser(QUIET=True)
            #warnings.simplefilter('ignore', PDBConstructionWarning)
    structure = parser.get_structure(file=filepath, id=samplename)
  
    res_list = [] 
    pLDDT_tot = 0

    for model in structure:
        for chain in model:
            chain_res_list = chain.get_unpacked_list()
            res_list.extend(chain_res_list)
            for residue in chain:
                atom_list = residue.get_unpacked_list()
                num_atoms = len(atom_list)
                res_pLDDT_tot = 0
                for atom in residue: # ESMFold and others have separate atom-wise values 
                    atom_pLDDT = atom.get_bfactor()
                    res_pLDDT_tot += atom_pLDDT
                res_pLDDT = (res_pLDDT_tot / num_atoms)
                pLDDT_tot += res_pLDDT
    num_res = len(res_list)
    pLDDT_mean = (pLDDT_tot / num_res) 
   
    if (pLDDT_mean < 1): # Should really check each program, but <1 pLDDTs are highlt improbable, so let's just convert to percentage
        pLDDT_mean *= 100

    return(round(pLDDT_mean,2))

      
