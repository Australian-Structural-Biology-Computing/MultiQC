import logging
import re

from multiqc.base_module import BaseMultiqcModule, ModuleNoSamplesFound
from multiqc.plots import bargraph

from Bio import PDB

log = logging.getLogger(__name__)


class MultiqcModule(BaseMultiqcModule):
    """
    The module parses results generated by a variety of protein structure prediction programs in the [ProteinFold](https://nf-co.re/proteinfold/) pipeline.
    This includes [currently all WIP]:
        - [AlphaFold2](https://github.com/google-deepmind/alphafold)
        - [ColabFold](https://github.com/sokrypton/ColabFold) [currently not being worked on]
        - [ESMFold](https://github.com/facebookresearch/esm)
        - [RoseTTaFold-All-Atom](https://github.com/baker-laboratory/RoseTTAFold-All-Atom)
        - [HelixFold3](https://github.com/PaddlePaddle/PaddleHelix/tree/dev/apps/protein_folding/helixfold3) 

    This is intended to provide a summary of useful metrics for mass 'folding' a large set of proteins, either in terms of finishing for mulitmer interactions or comparing methods across whole proteomes. It provides a visual 'at-a-glance' report of relevant metrics (average pLDDT, iPTM, *etc*) and does not replace the per-protein interactive plot generated from nfcore/proteinfold

    ```
    Here's what some raw code looks like
    ```

    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="ProteinFold",
            anchor="proteinfold",
            href=["https://nf-co.re/proteinfold", "https://github.com/google-deepmind/alphafold", "https://github.com/sokrypton/ColabFold", "https://github.com/facebookresearch/esm", "https://github.com/baker-laboratory/RoseTTAFold-All-Atom", "https://github.com/PaddlePaddle/PaddleHelix/tree/dev/apps/protein_folding/helixfold3"],
            info="ProteinFold - protein structure inference methods through a single nextflow pipeline interface",
            doi=["10.1038/s41586-021-03819-2", "10.1038/s41592-022-01488-1",  "10.1126/science.ade2574", "10.1126/science.adl2528", "10.48550/arXiv.2408.16975"],
        )
    
        for f in self.find_log_files('proteinfold/structs'):
            self.add_data_source(f, section='structs')        
            filepath = f['root'] + '/' + f['fn']
            samplename = f['s_name']
            pLDDT = self.parse_pdb_file(filepath, samplename)
            print(f"'file: {filepath} - confidence {pLDDT}")
  #     self.general_stats_addcols(
  #         data_by_sample,
  #         {
  #             "MSA depth": {
  #                 "title": "Related Sequence Depth (MSAs)",
  #                 "description": "The number of related sequences (across the whole protein) that could be retrieved from the MSA (Multiple Sequence Alignment) stage",
  #             }, 
  #             "Average Confidence": {
  #                 "title": "Confidence (average plDDT)",
  #                 "description": "Structure prediction confidence score across all residues in the protein - from the mean pLDDT (predicted Local Distance Difference Test) value",
  #                 "max": 100,
  #                 "min": 0,
  #                 "scale": "RdYlGn",
  #             },
  #             "Interface score": {
  #                 "title": "Interface accuracy (iPTM)",
  #                 "description": "Accuracy of the relative positions of two protein subunits from a mulitmer calcuation - from the iPTM (interface predicted Template Modelling) score",
  #                 "max": 1,
  #                 "min": 0,
  #                 "scale": "Greens",
  #             },
  #         },
  #     )


    def parse_pdb_file(self, filepath, samplename):
        '''
        Uses the BioPython PDB packaged to extract pLDDT values from the b-factor column. Iterates of PDB objects rather than processes raw file 
        '''
        parser = PDB.PDBParser()
        structure = parser.get_structure(file=filepath, id=samplename)
        res_list = [] 
        pLDDT_tot = 0
        for model in structure:
            for chain in model:
                chain_res_list = chain.get_unpacked_list()
                res_list.extend(chain_res_list)
                for residue in chain:
                    atom_list = residue.get_unpacked_list()
                    num_atoms = len(atom_list)
                    res_pLDDT_tot = 0
                    for atom in residue: # ESMFold and others have separate atom-wise values 
                        atom_pLDDT = atom.get_bfactor()
                        res_pLDDT_tot += atom_pLDDT
                    res_pLDDT = (res_pLDDT_tot / num_atoms)
                    pLDDT_tot += res_pLDDT
        num_res = len(res_list)
        pLDDT_mean = (pLDDT_tot / num_res) 
        # TO DO should really check each program, but <1 pLDDTs are impossible, so let's just convert to percentage
        if (pLDDT_mean < 1):
            pLDDT_mean *= 100
        return(round(pLDDT_mean,2))

        
